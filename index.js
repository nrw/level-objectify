// Generated by CoffeeScript 1.7.1
(function() {
  var exports, getKeys, getPaths, patcher, reduce,
    __slice = [].slice;

  patcher = require('patcher');

  reduce = require('stream-reduce');

  exports = module.exports = function(opts) {
    var compile, computeBatch, computePatch;
    if (opts == null) {
      opts = {};
    }
    opts.separator || (opts.separator = '\xff');
    opts.depth || (opts.depth = 0);
    if (opts.depth < 0) {
      opts.depth = 0;
    }
    computePatch = patcher.computePatch;
    computeBatch = function(prev, next) {
      var add, batch, key, keys, patch, path, paths, state, _i, _j, _k, _l, _len, _len1, _len2, _len3;
      patch = computePatch(prev, next);
      paths = getPaths(patch, opts.depth);
      batch = [];
      add = function(type, path, value) {
        var key, obj;
        if (value == null) {
          value = null;
        }
        key = path.join(opts.separator);
        obj = {
          type: type,
          key: key
        };
        if (value) {
          obj.value = value;
        }
        return batch.push(obj);
      };
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        if (path.length < opts.depth + 1) {
          state = prev;
          for (_j = 0, _len1 = path.length; _j < _len1; _j++) {
            key = path[_j];
            state = state != null ? state[key] : void 0;
          }
          keys = getKeys(state, path, opts.depth - path.length);
          for (_k = 0, _len2 = keys.length; _k < _len2; _k++) {
            key = keys[_k];
            add('del', key);
          }
        } else {
          state = next;
          for (_l = 0, _len3 = path.length; _l < _len3; _l++) {
            key = path[_l];
            state = state != null ? state[key] : void 0;
          }
          if (state) {
            add('put', path, state);
          } else {
            add('del', path);
          }
        }
      }
      return batch;
    };
    compile = function(cb) {
      var reducer, stream;
      if (cb == null) {
        cb = function() {};
      }
      reducer = function(acc, h) {
        var fix, id, obj, prefix, _i, _j, _len, _ref;
        _ref = h.key.split(opts.separator), prefix = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), id = _ref[_i++];
        obj = acc;
        for (_j = 0, _len = prefix.length; _j < _len; _j++) {
          fix = prefix[_j];
          obj[fix] || (obj[fix] = {});
          obj = obj[fix];
        }
        obj[id] = h.value;
        return acc;
      };
      stream = reduce(reducer, {});
      stream.on('data', function(data) {
        return cb(null, data);
      });
      return stream.on('err', cb);
    };
    return {
      computeBatch: computeBatch,
      computePatch: computePatch,
      compile: compile,
      writeStream: compile,
      createWriteStream: compile
    };
  };

  getKeys = function(state, base, depth, acc) {
    var k, path, v;
    if (acc == null) {
      acc = [];
    }
    if (depth < 0) {
      acc.push(base);
      return base;
    }
    for (k in state) {
      v = state[k];
      path = base.slice(0);
      path.push(k);
      getKeys(v, path, depth - 1, acc);
    }
    return acc;
  };

  getPaths = function(patch, depth, base, acc) {
    var k, p, path, rm, v, _i, _len;
    if (base == null) {
      base = [];
    }
    if (acc == null) {
      acc = [];
    }
    if (depth < 0) {
      acc.push(base);
      return base;
    }
    for (k in patch) {
      v = patch[k];
      path = base.slice(0);
      if (k === '$r') {
        if (!Array.isArray(v)) {
          v = [v];
        }
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          rm = v[_i];
          p = path.slice(0);
          p.push(rm);
          getPaths(null, -1, p, acc);
        }
      } else {
        path.push(k);
        getPaths(v, depth - 1, path, acc);
      }
    }
    return acc;
  };

}).call(this);
